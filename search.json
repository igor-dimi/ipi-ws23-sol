[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IPI WS23/24 Solutions",
    "section": "",
    "text": "Preface\nSolutions of the assignment sheets for the lecture “IPI WS23/24” at Uni Heidelberg."
  },
  {
    "objectID": "01/01.html#aufgabe-3",
    "href": "01/01.html#aufgabe-3",
    "title": "Zettel 01",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\n\nIn der VL beschriebe TM ist ein “Transducer”, d.h. ein Automat, das aus einem Input ein Output produziert. Die Beschreibung in der Online-version definiert die TM als ein “Acceptor”. D.h. ein Automat, das fuer eine gegebene Eingabe “Yes” oder “No” produziert. Jedoch kann die Online Version auch als ein Transducer betrieben werden.\nDie online Version erlaubt dem Schreib-/Lesekopf keine Bewegung bei einem Uebergang. Also darf der Kopf auf dem gleichen Feld bleiben. In der VL-version sind dagegen nur die Bewegungen “links” oder “rechts” definiert.\nDie Online-version hat einen “Blank” Symbol, die VL-version hingegen nicht.\n\n\n\n3.2\nWie im Online-tutorial erklaert entsprechen die Zustaende der TM dem “Rechenfortschritt” der Berechnung. (Computational Progress).\nBei der “Even number of Zeros”-TM gibt es zwei Zustaende \\(q_0\\) und \\(q_1\\):\n\n\\(q_0\\) entspricht der Situation, dass bis jetzt eine gerade Anzahl von 0’s gelesen wurde.\n\\(q_1\\) enptricht der Situation, dass bist gelesene Anzahl von 0’s ungerade ist.\n\nOder kuerzer:\n\\[\\begin{align*}\nq_0 &\\iff \\#0's \\equiv 0\\mod2 \\\\\nq_1 &\\iff \\#0's \\equiv 1\\mod2\n\\end{align*}\\]\nAm Anfang der Berechnung ist die Anzahl der gelesenen 0’s gleich 0. Somit ist \\(q_0\\) der initiale Zustand. Die Uebergaenge sind so definiert, dass das Ablesen einer 0 einen Zustanduebergang \\(q_{i} \\rightarrow q_{i\\oplus 1}\\) verursacht, wobei \\(i\\oplus 1\\) Addition mod 2 ist. Hingegen verursacht das Ablesen einer 1 keinen Zustanduebergang: \\(q_{i} \\rightarrow q_{i}\\) D.h. das Ablesen einer 0 ‘flippt’ die Paritaet der 0’s und Ablesen einer 1 hat keinen Einfluss darauf. Der Kopf bewegt sich rechts bis das ‘Blank’ erreicht wird. Falls dann der Zustand \\(q_0\\) ist, ist ein Uebergang auf \\(q_{\\text{accept}}\\) definiert und die Maschine akzeptiert somit die Eingabe. Sonnst sind keine Uebergange mehr definiert und die Berechnung terminiert in einem nicht-akzeptierenden Zustand.\nSiehe Figure 1 und Figure 2 fuer die Uebergangstabelle und den Ubergangsgraph\n\n\n\n\n\n\nFigure 1: Uebergangstabelle\n\n\n\n\n\n\n\n\n\nFigure 2: Uebergangsgraph\n\n\n\n\n\n\n\n3.3\nIn der VL definierte TM enthaelt kein “Blank”-symbol. Stattdessen symbolisiert “0” das Ender einer Zeichenkette von Einsen. Da, in der Online-version es “Blanks” gibt, ersetzten wir 0 durch “Blanks”.\nDas Programm zur Verdoppelung einer Einsenkette (Auch im Zip als txt datei enthalten):\n// Input: a string of 1's of length n\n// Ouput: a string of 1's of length 2n\n// Example: if 111 is given as input. The machine terminates at an accepting state\n// with 111111 as the string on the band. \n//\n//\n\n\nname: double up a string of 1's\ninit: q1\naccept: q8\n\nq1, 1\nq2,X,&gt;\n\nq2,_\nq3,Y,&lt;\n\nq2,1\nq2,1,&gt;\n\nq3,1\nq3,1,&lt;\n\nq3,X\nq4,1,&gt;\n\nq4,1\nq5,X,&gt;\n\nq4,Y\nq8,1,&gt;\n\nq5,1\nq5,1,&gt;\n\nq5,Y\nq6,Y,&gt;\n\nq6,1\nq6,1,&gt;\n\nq6,_\nq7,1,&lt;\n\nq7,1\nq7,1,&lt;\n\nq7,Y\nq3,Y,&lt;\nWir haben das Program auf die Inputs 1, 11 und 11111 getestet und richtige Ergebnisse erhalten:"
  },
  {
    "objectID": "02/03.html#aufgabe-3",
    "href": "02/03.html#aufgabe-3",
    "title": "Zettel 02",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\nEine sprache fuer lineare Gleichungssysteme kann z.B. durch folgende EBNF-syntaxbeschreibung definiert werden:\n\\[\\begin{align*}\n    \\langle Gleichungssystem\\rangle &::= \\langle Gleichung\\rangle\\{\\underline{\\backslash n} \\langle Gleichung\\rangle\\} \\\\\n    \\langle Gleichung\\rangle &::= [\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\{\\langle Vorzeichen\\rangle[\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\}\\underline{=}\\langle Zahl\\rangle \\\\\n    \\langle Zahl\\rangle  &::= \\langle Ersteziffer\\rangle \\{\\langle Ziffer\\rangle \\} \\\\\n    \\langle Ersteziffer\\rangle  &::= \\underline{1} |\n                       \\underline{2} |\n                       \\underline{3} |\n                       \\underline{4} |\n                       \\underline{5} |\n                       \\underline{6} |\n                       \\underline{7} |\n                       \\underline{8} |\n                       \\underline{9} | \\\\\n    \\langle Ziffer\\rangle  &::= \\underline{0} | \\langle Ersteziffer\\rangle  \\\\\n    \\langle Index\\rangle  &::= \\underline{_0} | \\langle Subzahl\\rangle  \\\\\n    \\langle Subzahl\\rangle  &::= \\langle Erstesubziffer\\rangle \\{\\langle Subziffer\\rangle \\} \\\\\n    \\langle Erstesubziffer\\rangle  &::= \\underline{_1} |\n                       \\underline{_2} |\n                       \\underline{_3} |\n                       \\underline{_4} |\n                       \\underline{_5} |\n                       \\underline{_6} |\n                       \\underline{_7} |\n                       \\underline{_8} |\n                       \\underline{_9} | \\\\\n    \\langle Subziffer\\rangle  &::= \\underline{_0} | \\langle Erstesubziffer\\rangle  \n\\end{align*}\\]\nDie Anforderung “Die Anzahl der Variablen ist gleich der Anzahl der Gleichungen” ist eine Beschreibung die von dem Kontext des Erzeugten Wortes abhaengt - gueltige Gleichungssysteme duerfen beliebige Anzahl an Variablen haben. Da mit EBNF nur kontextfreie Sprachen definiert werden koennen ist diese Anforderung nicht umsetzbar."
  }
]