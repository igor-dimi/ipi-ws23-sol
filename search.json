[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IPI WS23/24 Solutions",
    "section": "",
    "text": "Preface\nSolutions of the assignment sheets for the lecture “IPI WS23/24” at Uni Heidelberg."
  },
  {
    "objectID": "01/01.html#aufgabe-3",
    "href": "01/01.html#aufgabe-3",
    "title": "Zettel 01",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\n\nIn der VL beschriebe TM ist ein “Transducer”, d.h. ein Automat, das aus einem Input ein Output produziert. Die Beschreibung in der Online-version definiert die TM als ein “Acceptor”. D.h. ein Automat, das fuer eine gegebene Eingabe “Yes” oder “No” produziert. Jedoch kann die Online Version auch als ein Transducer betrieben werden.\nDie online Version erlaubt dem Schreib-/Lesekopf keine Bewegung bei einem Uebergang. Also darf der Kopf auf dem gleichen Feld bleiben. In der VL-version sind dagegen nur die Bewegungen “links” oder “rechts” definiert.\nDie Online-version hat einen “Blank” Symbol, die VL-version hingegen nicht.\n\n\n\n3.2\nWie im Online-tutorial erklaert entsprechen die Zustaende der TM dem “Rechenfortschritt” der Berechnung. (Computational Progress).\nBei der “Even number of Zeros”-TM gibt es zwei Zustaende \\(q_0\\) und \\(q_1\\):\n\n\\(q_0\\) entspricht der Situation, dass bis jetzt eine gerade Anzahl von 0’s gelesen wurde.\n\\(q_1\\) enptricht der Situation, dass bist gelesene Anzahl von 0’s ungerade ist.\n\nOder kuerzer:\n\\[\\begin{align*}\nq_0 &\\iff \\#0's \\equiv 0\\mod2 \\\\\nq_1 &\\iff \\#0's \\equiv 1\\mod2\n\\end{align*}\\]\nAm Anfang der Berechnung ist die Anzahl der gelesenen 0’s gleich 0. Somit ist \\(q_0\\) der initiale Zustand. Die Uebergaenge sind so definiert, dass das Ablesen einer 0 einen Zustanduebergang \\(q_{i} \\rightarrow q_{i\\oplus 1}\\) verursacht, wobei \\(i\\oplus 1\\) Addition mod 2 ist. Hingegen verursacht das Ablesen einer 1 keinen Zustanduebergang: \\(q_{i} \\rightarrow q_{i}\\) D.h. das Ablesen einer 0 ‘flippt’ die Paritaet der 0’s und Ablesen einer 1 hat keinen Einfluss darauf. Der Kopf bewegt sich rechts bis das ‘Blank’ erreicht wird. Falls dann der Zustand \\(q_0\\) ist, ist ein Uebergang auf \\(q_{\\text{accept}}\\) definiert und die Maschine akzeptiert somit die Eingabe. Sonnst sind keine Uebergange mehr definiert und die Berechnung terminiert in einem nicht-akzeptierenden Zustand.\nSiehe Figure 1 und Figure 2 fuer die Uebergangstabelle und den Ubergangsgraph\n\n\n\n\n\n\nFigure 1: Uebergangstabelle\n\n\n\n\n\n\n\n\n\nFigure 2: Uebergangsgraph\n\n\n\n\n\n\n\n3.3\nIn der VL definierte TM enthaelt kein “Blank”-symbol. Stattdessen symbolisiert “0” das Ender einer Zeichenkette von Einsen. Da, in der Online-version es “Blanks” gibt, ersetzten wir 0 durch “Blanks”.\nDas Programm zur Verdoppelung einer Einsenkette (Auch im Zip als txt datei enthalten):\n// Input: a string of 1's of length n\n// Ouput: a string of 1's of length 2n\n// Example: if 111 is given as input. The machine terminates at an accepting state\n// with 111111 as the string on the band. \n//\n//\n\n\nname: double up a string of 1's\ninit: q1\naccept: q8\n\nq1, 1\nq2,X,&gt;\n\nq2,_\nq3,Y,&lt;\n\nq2,1\nq2,1,&gt;\n\nq3,1\nq3,1,&lt;\n\nq3,X\nq4,1,&gt;\n\nq4,1\nq5,X,&gt;\n\nq4,Y\nq8,1,&gt;\n\nq5,1\nq5,1,&gt;\n\nq5,Y\nq6,Y,&gt;\n\nq6,1\nq6,1,&gt;\n\nq6,_\nq7,1,&lt;\n\nq7,1\nq7,1,&lt;\n\nq7,Y\nq3,Y,&lt;\nWir haben das Program auf die Inputs 1, 11 und 11111 getestet und richtige Ergebnisse erhalten:"
  },
  {
    "objectID": "02/02.html#aufgabe-2",
    "href": "02/02.html#aufgabe-2",
    "title": "Zettel 02",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\nIdee: Vertausche erstes 0 und letzets 1 und interpretiere die Anzahl der 1’en auf dem Band als das Ergebniss.\nSeien z.B.: \\(n := 4, m := 3\\). Dann gilt:\n\\[\\begin{align*}\n    4 + 3 &\\equiv 1111\\fbox{0}11\\fbox{1}0 &&\\tag{Kodieren der Eingabe} \\\\\n          &\\Rightarrow 1111\\fbox{1}11\\fbox{0}0 &&\\tag{Vertausche erstes 0 und letztes 1} \\\\\n          & \\equiv 7 &&\\tag{Dekodieren der Ausgabe}\n\\end{align*}\\]\nDie TM - gegeben durch den folgenden Uebergangsgraph und Uebergangstabelle (Siehe Figure 2 und Figure 1) - realisiert diese Berechnung:\n\n\n\n\n\n\nFigure 1: Uebergangstabelle\n\n\n\n\n\n\n\n\n\nFigure 2: Uebergangsgraph\n\n\n\n\n\nBegruendung/Erklaerung der Vorgehensweise dieser TM:\n\n\\(q_0\\): Das ist der initialer Zustand. Lese 1’en und bewege den Kopf rechts bis erstes 0 gefunden wird. Ersetze diesen 0 durch einen 1, bewege den Kopf rechts und gehe zum Zustand \\(q_1\\) ueber\n\\(q_1\\): Erstes 0 wurde gefunden und durch 1 ersetzt. Lese 1’en und bewege den Kopf rechts bis der zweite 0 gefunden wird. Das ist das Ende der Eingabe. Bewege den Kopf ein mal links zurueck und gehe zum Zustand \\(q_2\\) ueber.\n\\(q_2\\): Der Kopf steht auf den letzten 1 der Eingabe. Ersetze diesen 1 durch einen 0 und bewege den Kopf ein mal links. Da das Ziel erreicht wurde (vertauschen der ersten 0 und letzten 1) gehe zum Zustand \\(q_A\\) ueber.\n\\(q_A\\): Das ist der akzeptierende Zustand. Falls die Eingabe gueltig ist haelt der TM im Zustand \\(q_A\\) mit dem richtigen Ergebniss auf dem Band.\n\nFolgendes Programm realisiert diese TM auf dem TM simulator, wobei 0’s durch blanks ersetz wurden, und letzte Bewegung ‘hold’ statt ‘links’ ist. (Das Programm ist auch als txt datei im Zip enthalten)\n//TM machine to add two numbers n and m\n//Input: string of n 1's and a string of m 1's seperated my a blank\n//Output: string of m + n 1's \n//Example: Input: \"1111 111\"\n//         Output: \"1111111\"    \n\nname: add two numbers \ninit: q0\naccept: qA\n\nq0,1\nq0,1,&gt;\n\nq0,_\nq1,1,&gt;\n\nq1,1\nq1,1,&gt;\n\nq1,_\nq2,_,&lt;\n\nq2,1\nqA,_,-\nAlternativ: link zur realisierung der TM auf der Webseite."
  },
  {
    "objectID": "02/02.html#aufgabe-3",
    "href": "02/02.html#aufgabe-3",
    "title": "Zettel 02",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\nEine sprache fuer lineare Gleichungssysteme kann z.B. durch folgende EBNF-syntaxbeschreibung definiert werden:\n\\[\\begin{align*}\n    \\langle Gleichungssystem\\rangle &::= \\langle Gleichung\\rangle\\{\\underline{\\backslash n} \\langle Gleichung\\rangle\\} \\\\\n    \\langle Gleichung\\rangle &::= [\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\{\\langle Vorzeichen\\rangle[\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\}\\underline{=}\\langle Zahl\\rangle \\\\\n    \\langle Vorzeichen \\rangle &::= \\underline{-} | \\underline{+} \\\\\n    \\langle Zahl\\rangle  &::= \\langle Ersteziffer\\rangle \\{\\langle Ziffer\\rangle \\} \\\\\n    \\langle Ersteziffer\\rangle  &::= \\underline{1} |\n                       \\underline{2} |\n                       \\underline{3} |\n                       \\underline{4} |\n                       \\underline{5} |\n                       \\underline{6} |\n                       \\underline{7} |\n                       \\underline{8} |\n                       \\underline{9} | \\\\\n    \\langle Ziffer\\rangle  &::= \\underline{0} | \\langle Ersteziffer\\rangle  \\\\\n    \\langle Index\\rangle  &::= \\underline{_0} | \\langle Subzahl\\rangle  \\\\\n    \\langle Subzahl\\rangle  &::= \\langle Erstesubziffer\\rangle \\{\\langle Subziffer\\rangle \\} \\\\\n    \\langle Erstesubziffer\\rangle  &::= \\underline{_1} |\n                       \\underline{_2} |\n                       \\underline{_3} |\n                       \\underline{_4} |\n                       \\underline{_5} |\n                       \\underline{_6} |\n                       \\underline{_7} |\n                       \\underline{_8} |\n                       \\underline{_9} | \\\\\n    \\langle Subziffer\\rangle  &::= \\underline{_0} | \\langle Erstesubziffer\\rangle  \n\\end{align*}\\]\nDie Anforderung “Die Anzahl der Variablen ist gleich der Anzahl der Gleichungen” ist eine Beschreibung die von dem Kontext des Erzeugten Wortes abhaengt - gueltige Gleichungssysteme duerfen beliebige Anzahl an Variablen haben. Da mit EBNF nur kontextfreie Sprachen definiert werden koennen ist diese Anforderung nicht umsetzbar."
  }
]