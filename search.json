[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IPI WS23/24 Solutions",
    "section": "",
    "text": "Preface\nSolutions of the assignment sheets for the lecture “IPI WS23/24” at Uni Heidelberg."
  },
  {
    "objectID": "01/01.html#aufgabe-3",
    "href": "01/01.html#aufgabe-3",
    "title": "Zettel 01",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\n\nIn der VL beschriebe TM ist ein “Transducer”, d.h. ein Automat, das aus einem Input ein Output produziert. Die Beschreibung in der Online-version definiert die TM als ein “Acceptor”. D.h. ein Automat, das fuer eine gegebene Eingabe “Yes” oder “No” produziert. Jedoch kann die Online Version auch als ein Transducer betrieben werden.\nDie online Version erlaubt dem Schreib-/Lesekopf keine Bewegung bei einem Uebergang. Also darf der Kopf auf dem gleichen Feld bleiben. In der VL-version sind dagegen nur die Bewegungen “links” oder “rechts” definiert.\nDie Online-version hat einen “Blank” Symbol, die VL-version hingegen nicht.\n\n\n\n3.2\nWie im Online-tutorial erklaert entsprechen die Zustaende der TM dem “Rechenfortschritt” der Berechnung. (Computational Progress).\nBei der “Even number of Zeros”-TM gibt es zwei Zustaende \\(q_0\\) und \\(q_1\\):\n\n\\(q_0\\) entspricht der Situation, dass bis jetzt eine gerade Anzahl von 0’s gelesen wurde.\n\\(q_1\\) enptricht der Situation, dass bist gelesene Anzahl von 0’s ungerade ist.\n\nOder kuerzer:\n\\[\\begin{align*}\nq_0 &\\iff \\#0's \\equiv 0\\mod2 \\\\\nq_1 &\\iff \\#0's \\equiv 1\\mod2\n\\end{align*}\\]\nAm Anfang der Berechnung ist die Anzahl der gelesenen 0’s gleich 0. Somit ist \\(q_0\\) der initiale Zustand. Die Uebergaenge sind so definiert, dass das Ablesen einer 0 einen Zustanduebergang \\(q_{i} \\rightarrow q_{i\\oplus 1}\\) verursacht, wobei \\(i\\oplus 1\\) Addition mod 2 ist. Hingegen verursacht das Ablesen einer 1 keinen Zustanduebergang: \\(q_{i} \\rightarrow q_{i}\\) D.h. das Ablesen einer 0 ‘flippt’ die Paritaet der 0’s und Ablesen einer 1 hat keinen Einfluss darauf. Der Kopf bewegt sich rechts bis das ‘Blank’ erreicht wird. Falls dann der Zustand \\(q_0\\) ist, ist ein Uebergang auf \\(q_{\\text{accept}}\\) definiert und die Maschine akzeptiert somit die Eingabe. Sonnst sind keine Uebergange mehr definiert und die Berechnung terminiert in einem nicht-akzeptierenden Zustand.\nSiehe Figure 1 und Figure 2 fuer die Uebergangstabelle und den Ubergangsgraph\n\n\n\n\n\n\nFigure 1: Uebergangstabelle\n\n\n\n\n\n\n\n\n\nFigure 2: Uebergangsgraph\n\n\n\n\n\n\n\n3.3\nIn der VL definierte TM enthaelt kein “Blank”-symbol. Stattdessen symbolisiert “0” das Ender einer Zeichenkette von Einsen. Da, in der Online-version es “Blanks” gibt, ersetzten wir 0 durch “Blanks”.\nDas Programm zur Verdoppelung einer Einsenkette (Auch im Zip als txt datei enthalten):\n// Input: a string of 1's of length n\n// Ouput: a string of 1's of length 2n\n// Example: if 111 is given as input. The machine terminates at an accepting state\n// with 111111 as the string on the band. \n//\n//\n\n\nname: double up a string of 1's\ninit: q1\naccept: q8\n\nq1, 1\nq2,X,&gt;\n\nq2,_\nq3,Y,&lt;\n\nq2,1\nq2,1,&gt;\n\nq3,1\nq3,1,&lt;\n\nq3,X\nq4,1,&gt;\n\nq4,1\nq5,X,&gt;\n\nq4,Y\nq8,1,&gt;\n\nq5,1\nq5,1,&gt;\n\nq5,Y\nq6,Y,&gt;\n\nq6,1\nq6,1,&gt;\n\nq6,_\nq7,1,&lt;\n\nq7,1\nq7,1,&lt;\n\nq7,Y\nq3,Y,&lt;\nWir haben das Program auf die Inputs 1, 11 und 11111 getestet und richtige Ergebnisse erhalten:"
  },
  {
    "objectID": "02/02.html#aufgabe-2",
    "href": "02/02.html#aufgabe-2",
    "title": "Zettel 02",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\nIdee: Vertausche erstes 0 und letzets 1 und interpretiere die Anzahl der 1’en auf dem Band als das Ergebniss.\nSeien z.B.: \\(n := 4, m := 3\\). Dann gilt:\n\\[\\begin{align*}\n    4 + 3 &\\equiv 1111\\fbox{0}11\\fbox{1}0 &&\\tag{Kodieren der Eingabe} \\\\\n          &\\Rightarrow 1111\\fbox{1}11\\fbox{0}0 &&\\tag{Vertausche erstes 0 und letztes 1} \\\\\n          & \\equiv 7 &&\\tag{Dekodieren der Ausgabe}\n\\end{align*}\\]\nDie TM - gegeben durch den folgenden Uebergangsgraph und Uebergangstabelle (Siehe Figure 2 und Figure 1) - realisiert diese Berechnung:\n\n\n\n\n\n\nFigure 1: Uebergangstabelle\n\n\n\n\n\n\n\n\n\nFigure 2: Uebergangsgraph\n\n\n\n\n\nBegruendung/Erklaerung der Vorgehensweise dieser TM:\n\n\\(q_0\\): Das ist der initialer Zustand. Lese 1’en und bewege den Kopf rechts bis erstes 0 gefunden wird. Ersetze diesen 0 durch einen 1, bewege den Kopf rechts und gehe zum Zustand \\(q_1\\) ueber\n\\(q_1\\): Erstes 0 wurde gefunden und durch 1 ersetzt. Lese 1’en und bewege den Kopf rechts bis der zweite 0 gefunden wird. Das ist das Ende der Eingabe. Bewege den Kopf ein mal links zurueck und gehe zum Zustand \\(q_2\\) ueber.\n\\(q_2\\): Der Kopf steht auf den letzten 1 der Eingabe. Ersetze diesen 1 durch einen 0 und bewege den Kopf ein mal links. Da das Ziel erreicht wurde (vertauschen der ersten 0 und letzten 1) gehe zum Zustand \\(q_A\\) ueber.\n\\(q_A\\): Das ist der akzeptierende Zustand. Falls die Eingabe gueltig ist haelt der TM im Zustand \\(q_A\\) mit dem richtigen Ergebniss auf dem Band.\n\nFolgendes Programm realisiert diese TM auf dem TM simulator, wobei 0’s durch blanks ersetz wurden, und letzte Bewegung ‘hold’ statt ‘links’ ist. (Das Programm ist auch als txt datei im Zip enthalten)\n//TM machine to add two numbers n and m\n//Input: string of n 1's and a string of m 1's seperated my a blank\n//Output: string of m + n 1's \n//Example: Input: \"1111 111\"\n//         Output: \"1111111\"    \n\nname: add two numbers \ninit: q0\naccept: qA\n\nq0,1\nq0,1,&gt;\n\nq0,_\nq1,1,&gt;\n\nq1,1\nq1,1,&gt;\n\nq1,_\nq2,_,&lt;\n\nq2,1\nqA,_,-\nAlternativ: link zur realisierung der TM auf der Webseite."
  },
  {
    "objectID": "02/02.html#aufgabe-3",
    "href": "02/02.html#aufgabe-3",
    "title": "Zettel 02",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\nEine sprache fuer lineare Gleichungssysteme kann z.B. durch folgende EBNF-syntaxbeschreibung definiert werden:\n\\[\\begin{align*}\n    \\langle Gleichungssystem\\rangle &::= \\langle Gleichung\\rangle\\{\\underline{\\backslash n} \\langle Gleichung\\rangle\\} \\\\\n    \\langle Gleichung\\rangle &::= [\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\{\\langle Vorzeichen\\rangle[\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\}\\underline{=}\\langle Zahl\\rangle \\\\\n    \\langle Vorzeichen \\rangle &::= \\underline{-} | \\underline{+} \\\\\n    \\langle Zahl\\rangle  &::= \\langle Ersteziffer\\rangle \\{\\langle Ziffer\\rangle \\} \\\\\n    \\langle Ersteziffer\\rangle  &::= \\underline{1} |\n                       \\underline{2} |\n                       \\underline{3} |\n                       \\underline{4} |\n                       \\underline{5} |\n                       \\underline{6} |\n                       \\underline{7} |\n                       \\underline{8} |\n                       \\underline{9} | \\\\\n    \\langle Ziffer\\rangle  &::= \\underline{0} | \\langle Ersteziffer\\rangle  \\\\\n    \\langle Index\\rangle  &::= \\underline{_0} | \\langle Subzahl\\rangle  \\\\\n    \\langle Subzahl\\rangle  &::= \\langle Erstesubziffer\\rangle \\{\\langle Subziffer\\rangle \\} \\\\\n    \\langle Erstesubziffer\\rangle  &::= \\underline{_1} |\n                       \\underline{_2} |\n                       \\underline{_3} |\n                       \\underline{_4} |\n                       \\underline{_5} |\n                       \\underline{_6} |\n                       \\underline{_7} |\n                       \\underline{_8} |\n                       \\underline{_9} | \\\\\n    \\langle Subziffer\\rangle  &::= \\underline{_0} | \\langle Erstesubziffer\\rangle  \n\\end{align*}\\]\nDie Anforderung “Die Anzahl der Variablen ist gleich der Anzahl der Gleichungen” ist eine Beschreibung die von dem Kontext des Erzeugten Wortes abhaengt - gueltige Gleichungssysteme duerfen beliebige Anzahl an Variablen haben. Da mit EBNF nur kontextfreie Sprachen definiert werden koennen ist diese Anforderung nicht umsetzbar."
  },
  {
    "objectID": "03/03.html#aufgabe-2",
    "href": "03/03.html#aufgabe-2",
    "title": "Zettel 03",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\n\n2.1\nFolgendes Program loesst das problem (auch im zip als potenz.cc enthalten)\n#include \"fcpp.hh\"\n\nint quadrat (int x)\n{\n  return x*x;\n}\n\nint potenz(int x, int n)\n{\n    return cond(n == 0, \n            1, \n            cond(n % 2 == 0, \n                quadrat(potenz(x, n / 2)), \n                x * potenz(x, n - 1)));\n}\n\n\nint main(int argc, char** argv)\n{\n    return print(potenz(\n      readarg_int(argc, argv, 1), \n      readarg_int(argc, argv, 2)));\n}\nArgumente muessen in der Konsole eingegeben werden, z.B.:\n$ ./potenz 4 3\n81"
  },
  {
    "objectID": "03/03.html#aufgabe-3",
    "href": "03/03.html#aufgabe-3",
    "title": "Zettel 03",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\nFolgendes Program realisiert die rekursive Berechnung der Binomialkoeffizienten (auch im Zip als binomial.cc enthalten):\n#include \"fcpp.hh\"\n\nint binomial(int n, int k)\n{\n    return cond(k == 0 || k == n, \n            1,\n            binomial(n - 1, k - 1) + binomial(n - 1, k));\n}\n\nint main(int argc, char** argv)\n{\n    return print(binomial(\n        readarg_int(argc, argv, 1),\n        readarg_int(argc, argv, 2)));\n}\nWir haben das Program auf verschieden Werte \\(n\\) und \\(k\\) getestet (zusammen mit der time Funktion fuer Messung der Laufzeit) und die Ergebnisse in der folgenden Tabelle zusammengefasst:\n\n\n\n\n\n\nNote\n\n\n\nSpecs des Systems auf der wir getestet haben:\n\nPC: ThinkCentre M700\nProcessors: 4 × Intel® Core™ i5-6400 CPU @ 2.70GHz\nMemory: 15,5 GiB of RAM\n\n\n\n\n\n\n\n\n\n\n\nBefehl\nErgebniss\nLaufzeit (real)\n\n\ntime ./binomial 1 0\n1\nreal 0m0,004s\n\n\ntime ./binomial 1 1\n1\nreal 0m0,002s\n\n\ntime ./binomial 3 2\n3\nreal 0m0,002s\n\n\ntime ./binomial 10 4\n210\nreal 0m0,004s\n\n\ntime ./binomial 20 13\n77520\nreal 0m0,007s\n\n\ntime ./binomial 32 15\n565722720\nreal 0m3,519s\n\n\ntime ./binomial 36 13\n-1984177696\nreal 0m13,791s\n\n\n\nWie aus der Tabelle zu sehen ist, ist die Laufzaut \\(&gt;10s\\) fuer die Berechnung time ./binomial 36 13 jedoch mit dem falschen Ergebniss -1984177696 statt das richtige \\(\\binom{36}{13} = 2310789600\\). Wir erklaeren dieses Phaenomen in der folgenden Teilaufgabe.\n\n\n3.2\nFuer \\(n = 34\\), \\(k = 18\\) liefert das Program\n$ ./binomial 34 18\n-2091005866\nim Gegensatz zu dem erwarteten mathematischen Ergebniss \\(\\binom{34}{18} = 2203961430\\).\nDieser ‘Fehler’ liegt an der 32 bit 2er Komplement Darstellung des Datentyps int auf dem Computer. Darunter koennen eine endliche Anzahl von int Zahlen dargestellt werden, die im Bereich \\([-2^{31}, 2^{31} - 1] = [-2147483648, 2147483648]\\) liegen. Das mathematische Ergebnis liegt also ausserhalb des darstellbaren Bereiches mit \\(2203961430 &gt; 2147483648\\).\nDa, unter der 2er Komplement Darstellung der MSB (Most Significant Bit) den Bereich der Negativen Zahlen representiert kann die Addition zweier groessen Zahlen, deren Ergebniss ausserhalb des darstellbaren Bereiches liegt wieder bei dem negativen Bereich landen, aehnlich wie Modulorechnung. Das wird als overflow bezeichnet.\n\n\n3.3\nSei \\(A_{n, n} = \\alpha = A_{n, 0}\\) und \\(\\beta := \\text{Die konstanten Kosten der Addition}\\). Dann gilt:\n\\[\\begin{align*}\n    &A_{n, k} = A_{n-1, k-1} + A_{n-1, k} + \\beta\n                \\tag{Rekursive Beziehung des Rechenaufwands} \\\\\n    &A_{n, 0} = \\alpha = A_{n, n}\n\\end{align*}\\]\nDa die rekursive Beziehungs des Rechenaufwands eine aehnliche Beziehung wie die Binomialkoeffizienten erfuellen koennen diese in einem paskalschen Dreieck wie folgt eingetragen werden (Siehe Figure 1)\n\n\n\nFigure 1: Kosten-dreieck\n\n\nBetrachten wir nur die Koeffizienten von \\(\\alpha\\) und \\(\\beta\\) seperat so erhalten wir folgende paskalschen Dreiecke (Siehe Figure 2)\n\n\n\nFigure 2: Konstanten-dreiecke\n\n\nVon diesen Figuren ist es leicht zu sehen, dass \\(\\alpha_{n, k} = B_{n, k}\\) und \\(\\beta_{n, k} = B_{n, k} - 1\\), wobei \\(\\alpha_{n, k}, \\beta_{n, k}\\) die Koeffizienten von \\(\\alpha\\) bzw. \\(\\beta\\) sind bzgl der Rechenaufwands \\(A_{n, k}\\).\nSomit erhalten wir:\n\\[A_{n, k} = B_{n, k}\\alpha + (B_{n,k} - 1)\\beta\\]\nFormaler Beweis:\nFuehre die Variablentransformation \\(\\tilde{A}_{n, k} := \\frac{A_{n, k} + \\beta}{\\alpha + \\beta}\\). Dann erhalten wir die folgende rekursive Gleichung:\n\\[\\begin{align*}\n    &\\tilde{A}_{n, k} = \\tilde{A}_{n-1, k-1} + \\tilde{A}_{n-1, k} \\\\\n    &\\tilde{A}_{n, 0} = 1 = \\tilde{A}_{n, n}\n\\end{align*}\\]\nDas ist genau die Definition des Binomialkoeffizientes \\(B_{n, k}\\). Somit gilt:\n\\[\\begin{align*}\n    \\tilde{A}_{n, k} &= B_{n, k} \\\\\n    \\Rightarrow A_{n, k} &= (\\alpha + \\beta)\\tilde{A}_{n, k} - \\beta \\\\\n                         &= (\\alpha + \\beta)B_{n, k} - \\beta \\quad \\blacksquare\n\\end{align*}\\]\n\n\n3.4\nFolgend geben wir die iterative Implementierung der Binomialkoeffizienten anhand einer tail-rekursiven Implemenierung der Fakultaet-funktion an (auch im Zip als binomial_fast.cc erhalten):\n#include \"fcpp.hh\"\n\n//iterative Implementierung der Fakultaetsfunktion durch Tail-recursion \n// mit fakit und fak\nint fakit(int res, int n)\n{\n    return cond(\n        n &gt; 1,\n        fakit(res * n, n - 1),\n        res\n    );\n}\n\nint fak(int n)\n{\n    return fakit(1, n);\n}\n\nint binomial_fast(int n, int k)\n{\n    return fak(n) / (fak(k) * fak(n - k));\n}\n\nint main(int argc, char** argv)\n{\n    return print(binomial_fast(\n        readarg_int(argc, argv, 1),\n        readarg_int(argc, argv, 2)));\n}\nDa, die Implementierung von Fakultaet fak \\(\\mathcal{O}(n)\\) ist , binomial_fast nur drei mal fak aufruft und nur zwei weitere Basisoperationen verwendet - eine Multiplikation und eine Division - hat diese Implementierung eine Laufzeitkomplexitaet von \\(\\mathcal{O}(n)\\).\nWir haben binomial und binomial_fast auf verschiedene Eingaben hinsichtlich Ausgaben und Geschwindigkeit getestet und die Ergebnisse in der folgenden Tabelle zusammengefasst (Table 1):\n\n\nTable 1: binomial vs binomial_fast\n\n\n\n\n\n\n\nBefehl\nErgebniss\nLaufzeit (real)\n\n\ntime ./binomial 10 4\ntime ./binomial_fast 10 4\n210\n210\nreal 0m0,004s\nreal 0m0,004s\n\n\ntime ./binomial 11 6\ntime ./binomial_fast 11 6\n462\n462\nreal 0m0,005s real 0m0,005s\n\n\ntime ./binomial 13 10\ntime ./binomial_fast 13 10\n286\n88\nreal 0m0,005s\nreal 0m0,004s\n\n\ntime ./binomial 20 13\ntime ./binomial_fast 20 13\n77520\n-2\nreal 0m0,006s\nreal 0m0,002s\n\n\ntime ./binomial 27 15\ntime ./binomial_fast 27 15\n17383860\n0\nreal 0m0,123s\nreal 0m0,004s\n\n\ntime ./binomial 32 15\ntime ./binomial_fast 32 15\n565722720\n-3\nreal 0m3,519s\nreal 0m0,004s\n\n\ntime ./binomial 34 19\ntime ./binomial_fast 34 19\n1855967520\n0\nreal 0m11,689s\nreal 0m0,002\n\n\ntime ./binomial 36 13\ntime ./binomial_fast 36 13\n-1984177696\n0\nreal 0m15,388s\nreal 0m0,004s\n\n\ntime ./binomial 39 23\ntime ./binomial_fast 39 23\n-943444674\ncore dumped\nreal 3m47,934s\nreal 0m0,086s\n\n\n\n\nDa binomial_fast eine lineare Laufzeitkomplezitaet hat bleibt die Laufzeit c. .004s fuer alle Eingaben.\nIm Gegensatz waechst die Laufzeit von binomial proportional zu dem mathematischen Wert \\(B_{n, k}\\) fuer Eingaben \\(n\\) und \\(k\\). Somit ist die Laufzeit sehr hoch fuer grosse Werte von \\(B_{n, k}\\).\nWie aus der Tabelle zu sehen ist, gibt es bereits ab \\(n = 27, k = 15\\) einen Unterschied und fuer hoehere Werte wie \\(n = 34, k = 19\\) oder \\(n = 36, k = 13\\) unterscheiden sich die Laufzeiten um mehr als 10s. Fuer \\(n = 39, k = 23\\) ist die Laufzeit von binomial sogar fast 4 minuten, wobei binomial_fast immer noch bei ~0.004s bleibt.\n\n\n3.5\nFuer diese Teilaufgabe verwenden wir wieder die obige Tabelle Table 1. Fuer die ersten zwei Zeilen, also fuer \\(n = 10, k = 4\\) und \\(n = 11, k = 6\\) liefern beide Programme die richtige mathematische Ergebnisse \\(\\binom{10}{4} = 210\\), bzw. \\(\\binom{11}{6} = 462\\). Jedoch liefert binomial_fast bereits ab der dritten Zeile, also fuer \\(n = 13, k = 10\\) ein falsches Ergebnis, wobei binomial bis der 7en Zeile, d.h fuer \\(n = 34, k = 19\\) richtige Ergebnisse liefert.\nWie in der Teilaufgabe 3.3 erklaert wurde, gibt es das sogenannte Phaenomen “overflow” fuer den Datentyp int. Die Fakultaetsfunktion waechst sehr schnell und hat bereits fuer die Eingabe 13 den Wert \\(13! = 6 227 020 800 &gt; 2 147 483 647 = 2^{31} - 1\\). Somit fuehrt bereits fak(13) zu einem overflow. Da, die Implementierung vonbinomial_fast die Funktion fak benutzt, liefert dieses Program fuer Eingaben \\(n \\geq 13\\) ein falsches Ergebnis."
  }
]