[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IPI WS23/24 Solutions",
    "section": "",
    "text": "Preface\nSolutions of the assignment sheets for the lecture “IPI WS23/24” at Uni Heidelberg."
  },
  {
    "objectID": "01/01.html#aufgabe-3",
    "href": "01/01.html#aufgabe-3",
    "title": "Zettel 01",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\n\nIn der VL beschriebe TM ist ein “Transducer”, d.h. ein Automat, das aus einem Input ein Output produziert. Die Beschreibung in der Online-version definiert die TM als ein “Acceptor”. D.h. ein Automat, das fuer eine gegebene Eingabe “Yes” oder “No” produziert. Jedoch kann die Online Version auch als ein Transducer betrieben werden.\nDie online Version erlaubt dem Schreib-/Lesekopf keine Bewegung bei einem Uebergang. Also darf der Kopf auf dem gleichen Feld bleiben. In der VL-version sind dagegen nur die Bewegungen “links” oder “rechts” definiert.\nDie Online-version hat einen “Blank” Symbol, die VL-version hingegen nicht.\n\n\n\n3.2\nWie im Online-tutorial erklaert entsprechen die Zustaende der TM dem “Rechenfortschritt” der Berechnung. (Computational Progress).\nBei der “Even number of Zeros”-TM gibt es zwei Zustaende \\(q_0\\) und \\(q_1\\):\n\n\\(q_0\\) entspricht der Situation, dass bis jetzt eine gerade Anzahl von 0’s gelesen wurde.\n\\(q_1\\) enptricht der Situation, dass bist gelesene Anzahl von 0’s ungerade ist.\n\nOder kuerzer:\n\\[\\begin{align*}\nq_0 &\\iff \\#0's \\equiv 0\\mod2 \\\\\nq_1 &\\iff \\#0's \\equiv 1\\mod2\n\\end{align*}\\]\nAm Anfang der Berechnung ist die Anzahl der gelesenen 0’s gleich 0. Somit ist \\(q_0\\) der initiale Zustand. Die Uebergaenge sind so definiert, dass das Ablesen einer 0 einen Zustanduebergang \\(q_{i} \\rightarrow q_{i\\oplus 1}\\) verursacht, wobei \\(i\\oplus 1\\) Addition mod 2 ist. Hingegen verursacht das Ablesen einer 1 keinen Zustanduebergang: \\(q_{i} \\rightarrow q_{i}\\) D.h. das Ablesen einer 0 ‘flippt’ die Paritaet der 0’s und Ablesen einer 1 hat keinen Einfluss darauf. Der Kopf bewegt sich rechts bis das ‘Blank’ erreicht wird. Falls dann der Zustand \\(q_0\\) ist, ist ein Uebergang auf \\(q_{\\text{accept}}\\) definiert und die Maschine akzeptiert somit die Eingabe. Sonnst sind keine Uebergange mehr definiert und die Berechnung terminiert in einem nicht-akzeptierenden Zustand.\nSiehe Figure 1 und Figure 2 fuer die Uebergangstabelle und den Ubergangsgraph\n\n\n\n\n\n\nFigure 1: Uebergangstabelle\n\n\n\n\n\n\n\n\n\nFigure 2: Uebergangsgraph\n\n\n\n\n\n\n\n3.3\nIn der VL definierte TM enthaelt kein “Blank”-symbol. Stattdessen symbolisiert “0” das Ender einer Zeichenkette von Einsen. Da, in der Online-version es “Blanks” gibt, ersetzten wir 0 durch “Blanks”.\nDas Programm zur Verdoppelung einer Einsenkette (Auch im Zip als txt datei enthalten):\n// Input: a string of 1's of length n\n// Ouput: a string of 1's of length 2n\n// Example: if 111 is given as input. The machine terminates at an accepting state\n// with 111111 as the string on the band. \n//\n//\n\n\nname: double up a string of 1's\ninit: q1\naccept: q8\n\nq1, 1\nq2,X,&gt;\n\nq2,_\nq3,Y,&lt;\n\nq2,1\nq2,1,&gt;\n\nq3,1\nq3,1,&lt;\n\nq3,X\nq4,1,&gt;\n\nq4,1\nq5,X,&gt;\n\nq4,Y\nq8,1,&gt;\n\nq5,1\nq5,1,&gt;\n\nq5,Y\nq6,Y,&gt;\n\nq6,1\nq6,1,&gt;\n\nq6,_\nq7,1,&lt;\n\nq7,1\nq7,1,&lt;\n\nq7,Y\nq3,Y,&lt;\nWir haben das Program auf die Inputs 1, 11 und 11111 getestet und richtige Ergebnisse erhalten:"
  },
  {
    "objectID": "02/02.html#aufgabe-2",
    "href": "02/02.html#aufgabe-2",
    "title": "Zettel 02",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\nIdee: Vertausche erstes 0 und letzets 1 und interpretiere die Anzahl der 1’en auf dem Band als das Ergebniss.\nSeien z.B.: \\(n := 4, m := 3\\). Dann gilt:\n\\[\\begin{align*}\n    4 + 3 &\\equiv 1111\\fbox{0}11\\fbox{1}0 &&\\tag{Kodieren der Eingabe} \\\\\n          &\\Rightarrow 1111\\fbox{1}11\\fbox{0}0 &&\\tag{Vertausche erstes 0 und letztes 1} \\\\\n          & \\equiv 7 &&\\tag{Dekodieren der Ausgabe}\n\\end{align*}\\]\nDie TM - gegeben durch den folgenden Uebergangsgraph und Uebergangstabelle (Siehe Figure 2 und Figure 1) - realisiert diese Berechnung:\n\n\n\n\n\n\nFigure 1: Uebergangstabelle\n\n\n\n\n\n\n\n\n\nFigure 2: Uebergangsgraph\n\n\n\n\n\nBegruendung/Erklaerung der Vorgehensweise dieser TM:\n\n\\(q_0\\): Das ist der initialer Zustand. Lese 1’en und bewege den Kopf rechts bis erstes 0 gefunden wird. Ersetze diesen 0 durch einen 1, bewege den Kopf rechts und gehe zum Zustand \\(q_1\\) ueber\n\\(q_1\\): Erstes 0 wurde gefunden und durch 1 ersetzt. Lese 1’en und bewege den Kopf rechts bis der zweite 0 gefunden wird. Das ist das Ende der Eingabe. Bewege den Kopf ein mal links zurueck und gehe zum Zustand \\(q_2\\) ueber.\n\\(q_2\\): Der Kopf steht auf den letzten 1 der Eingabe. Ersetze diesen 1 durch einen 0 und bewege den Kopf ein mal links. Da das Ziel erreicht wurde (vertauschen der ersten 0 und letzten 1) gehe zum Zustand \\(q_A\\) ueber.\n\\(q_A\\): Das ist der akzeptierende Zustand. Falls die Eingabe gueltig ist haelt der TM im Zustand \\(q_A\\) mit dem richtigen Ergebniss auf dem Band.\n\nFolgendes Programm realisiert diese TM auf dem TM simulator, wobei 0’s durch blanks ersetz wurden, und letzte Bewegung ‘hold’ statt ‘links’ ist. (Das Programm ist auch als txt datei im Zip enthalten)\n//TM machine to add two numbers n and m\n//Input: string of n 1's and a string of m 1's seperated my a blank\n//Output: string of m + n 1's \n//Example: Input: \"1111 111\"\n//         Output: \"1111111\"    \n\nname: add two numbers \ninit: q0\naccept: qA\n\nq0,1\nq0,1,&gt;\n\nq0,_\nq1,1,&gt;\n\nq1,1\nq1,1,&gt;\n\nq1,_\nq2,_,&lt;\n\nq2,1\nqA,_,-\nAlternativ: link zur realisierung der TM auf der Webseite."
  },
  {
    "objectID": "02/02.html#aufgabe-3",
    "href": "02/02.html#aufgabe-3",
    "title": "Zettel 02",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\nEine sprache fuer lineare Gleichungssysteme kann z.B. durch folgende EBNF-syntaxbeschreibung definiert werden:\n\\[\\begin{align*}\n    \\langle Gleichungssystem\\rangle &::= \\langle Gleichung\\rangle\\{\\underline{\\backslash n} \\langle Gleichung\\rangle\\} \\\\\n    \\langle Gleichung\\rangle &::= [\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\{\\langle Vorzeichen\\rangle[\\langle Zahl\\rangle]\\underline{x}\\langle Index\\rangle\\}\\underline{=}\\langle Zahl\\rangle \\\\\n    \\langle Vorzeichen \\rangle &::= \\underline{-} | \\underline{+} \\\\\n    \\langle Zahl\\rangle  &::= \\langle Ersteziffer\\rangle \\{\\langle Ziffer\\rangle \\} \\\\\n    \\langle Ersteziffer\\rangle  &::= \\underline{1} |\n                       \\underline{2} |\n                       \\underline{3} |\n                       \\underline{4} |\n                       \\underline{5} |\n                       \\underline{6} |\n                       \\underline{7} |\n                       \\underline{8} |\n                       \\underline{9} | \\\\\n    \\langle Ziffer\\rangle  &::= \\underline{0} | \\langle Ersteziffer\\rangle  \\\\\n    \\langle Index\\rangle  &::= \\underline{_0} | \\langle Subzahl\\rangle  \\\\\n    \\langle Subzahl\\rangle  &::= \\langle Erstesubziffer\\rangle \\{\\langle Subziffer\\rangle \\} \\\\\n    \\langle Erstesubziffer\\rangle  &::= \\underline{_1} |\n                       \\underline{_2} |\n                       \\underline{_3} |\n                       \\underline{_4} |\n                       \\underline{_5} |\n                       \\underline{_6} |\n                       \\underline{_7} |\n                       \\underline{_8} |\n                       \\underline{_9} | \\\\\n    \\langle Subziffer\\rangle  &::= \\underline{_0} | \\langle Erstesubziffer\\rangle  \n\\end{align*}\\]\nDie Anforderung “Die Anzahl der Variablen ist gleich der Anzahl der Gleichungen” ist eine Beschreibung die von dem Kontext des Erzeugten Wortes abhaengt - gueltige Gleichungssysteme duerfen beliebige Anzahl an Variablen haben. Da mit EBNF nur kontextfreie Sprachen definiert werden koennen ist diese Anforderung nicht umsetzbar."
  },
  {
    "objectID": "03/03.html#aufgabe-2",
    "href": "03/03.html#aufgabe-2",
    "title": "Zettel 03",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\n\n2.1\nFolgendes Program loesst das problem (auch im zip als potenz.cc enthalten)\n#include \"fcpp.hh\"\n\nint quadrat (int x)\n{\n  return x*x;\n}\n\nint potenz(int x, int n)\n{\n    return cond(n == 0, \n            1, \n            cond(n % 2 == 0, \n                quadrat(potenz(x, n / 2)), \n                x * potenz(x, n - 1)));\n}\n\n\nint main(int argc, char** argv)\n{\n    return print(potenz(\n      readarg_int(argc, argv, 1), \n      readarg_int(argc, argv, 2)));\n}\nArgumente muessen in der Konsole eingegeben werden, z.B.:\n$ ./potenz 4 3\n81"
  },
  {
    "objectID": "03/03.html#aufgabe-3",
    "href": "03/03.html#aufgabe-3",
    "title": "Zettel 03",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\nFolgendes Program realisiert die rekursive Berechnung der Binomialkoeffizienten (auch im Zip als binomial.cc enthalten):\n#include \"fcpp.hh\"\n\nint binomial(int n, int k)\n{\n    return cond(k == 0 || k == n, \n            1,\n            binomial(n - 1, k - 1) + binomial(n - 1, k));\n}\n\nint main(int argc, char** argv)\n{\n    return print(binomial(\n        readarg_int(argc, argv, 1),\n        readarg_int(argc, argv, 2)));\n}\nWir haben das Program auf verschieden Werte \\(n\\) und \\(k\\) getestet (zusammen mit der time Funktion fuer Messung der Laufzeit) und die Ergebnisse in der folgenden Tabelle zusammengefasst:\n\n\n\n\n\n\nNote\n\n\n\nSpecs des Systems auf der wir getestet haben:\n\nPC: ThinkCentre M700\nProcessors: 4 × Intel® Core™ i5-6400 CPU @ 2.70GHz\nMemory: 15,5 GiB of RAM\n\n\n\n\n\n\n\n\n\n\n\nBefehl\nErgebniss\nLaufzeit (real)\n\n\ntime ./binomial 1 0\n1\nreal 0m0,004s\n\n\ntime ./binomial 1 1\n1\nreal 0m0,002s\n\n\ntime ./binomial 3 2\n3\nreal 0m0,002s\n\n\ntime ./binomial 10 4\n210\nreal 0m0,004s\n\n\ntime ./binomial 20 13\n77520\nreal 0m0,007s\n\n\ntime ./binomial 32 15\n565722720\nreal 0m3,519s\n\n\ntime ./binomial 36 13\n-1984177696\nreal 0m13,791s\n\n\n\nWie aus der Tabelle zu sehen ist, ist die Laufzaut \\(&gt;10s\\) fuer die Berechnung time ./binomial 36 13 jedoch mit dem falschen Ergebniss -1984177696 statt das richtige \\(\\binom{36}{13} = 2310789600\\). Wir erklaeren dieses Phaenomen in der folgenden Teilaufgabe.\n\n\n3.2\nFuer \\(n = 34\\), \\(k = 18\\) liefert das Program\n$ ./binomial 34 18\n-2091005866\nim Gegensatz zu dem erwarteten mathematischen Ergebniss \\(\\binom{34}{18} = 2203961430\\).\nDieser ‘Fehler’ liegt an der 32 bit 2er Komplement Darstellung des Datentyps int auf dem Computer. Darunter koennen eine endliche Anzahl von int Zahlen dargestellt werden, die im Bereich \\([-2^{31}, 2^{31} - 1] = [-2147483648, 2147483648]\\) liegen. Das mathematische Ergebnis liegt also ausserhalb des darstellbaren Bereiches mit \\(2203961430 &gt; 2147483648\\).\nDa, unter der 2er Komplement Darstellung der MSB (Most Significant Bit) den Bereich der Negativen Zahlen representiert kann die Addition zweier groessen Zahlen, deren Ergebniss ausserhalb des darstellbaren Bereiches liegt wieder bei dem negativen Bereich landen, aehnlich wie Modulorechnung. Das wird als overflow bezeichnet.\n\n\n3.3\nSei \\(A_{n, n} = \\alpha = A_{n, 0}\\) und \\(\\beta := \\text{Die konstanten Kosten der Addition}\\). Dann gilt:\n\\[\\begin{align*}\n    &A_{n, k} = A_{n-1, k-1} + A_{n-1, k} + \\beta\n                \\tag{Rekursive Beziehung des Rechenaufwands} \\\\\n    &A_{n, 0} = \\alpha = A_{n, n}\n\\end{align*}\\]\nDa die rekursive Beziehungs des Rechenaufwands eine aehnliche Beziehung wie die Binomialkoeffizienten erfuellen koennen diese in einem paskalschen Dreieck wie folgt eingetragen werden (Siehe Figure 1)\n\n\n\nFigure 1: Kosten-dreieck\n\n\nBetrachten wir nur die Koeffizienten von \\(\\alpha\\) und \\(\\beta\\) seperat so erhalten wir folgende paskalschen Dreiecke (Siehe Figure 2)\n\n\n\nFigure 2: Konstanten-dreiecke\n\n\nVon diesen Figuren ist es leicht zu sehen, dass \\(\\alpha_{n, k} = B_{n, k}\\) und \\(\\beta_{n, k} = B_{n, k} - 1\\), wobei \\(\\alpha_{n, k}, \\beta_{n, k}\\) die Koeffizienten von \\(\\alpha\\) bzw. \\(\\beta\\) sind bzgl der Rechenaufwands \\(A_{n, k}\\).\nSomit erhalten wir:\n\\[A_{n, k} = B_{n, k}\\alpha + (B_{n,k} - 1)\\beta\\]\nFormaler Beweis:\nFuehre die Variablentransformation \\(\\tilde{A}_{n, k} := \\frac{A_{n, k} + \\beta}{\\alpha + \\beta}\\). Dann erhalten wir die folgende rekursive Gleichung:\n\\[\\begin{align*}\n    &\\tilde{A}_{n, k} = \\tilde{A}_{n-1, k-1} + \\tilde{A}_{n-1, k} \\\\\n    &\\tilde{A}_{n, 0} = 1 = \\tilde{A}_{n, n}\n\\end{align*}\\]\nDas ist genau die Definition des Binomialkoeffizientes \\(B_{n, k}\\). Somit gilt:\n\\[\\begin{align*}\n    \\tilde{A}_{n, k} &= B_{n, k} \\\\\n    \\Rightarrow A_{n, k} &= (\\alpha + \\beta)\\tilde{A}_{n, k} - \\beta \\\\\n                         &= (\\alpha + \\beta)B_{n, k} - \\beta \\quad \\blacksquare\n\\end{align*}\\]\n\n\n3.4\nFolgend geben wir die iterative Implementierung der Binomialkoeffizienten anhand einer tail-rekursiven Implemenierung der Fakultaet-funktion an (auch im Zip als binomial_fast.cc erhalten):\n#include \"fcpp.hh\"\n\n//iterative Implementierung der Fakultaetsfunktion durch Tail-recursion \n// mit fakit und fak\nint fakit(int res, int n)\n{\n    return cond(\n        n &gt; 1,\n        fakit(res * n, n - 1),\n        res\n    );\n}\n\nint fak(int n)\n{\n    return fakit(1, n);\n}\n\nint binomial_fast(int n, int k)\n{\n    return fak(n) / (fak(k) * fak(n - k));\n}\n\nint main(int argc, char** argv)\n{\n    return print(binomial_fast(\n        readarg_int(argc, argv, 1),\n        readarg_int(argc, argv, 2)));\n}\nDa, die Implementierung von Fakultaet fak \\(\\mathcal{O}(n)\\) ist , binomial_fast nur drei mal fak aufruft und nur zwei weitere Basisoperationen verwendet - eine Multiplikation und eine Division - hat diese Implementierung eine Laufzeitkomplexitaet von \\(\\mathcal{O}(n)\\).\nWir haben binomial und binomial_fast auf verschiedene Eingaben hinsichtlich Ausgaben und Geschwindigkeit getestet und die Ergebnisse in der folgenden Tabelle zusammengefasst (Table 1):\n\n\nTable 1: binomial vs binomial_fast\n\n\n\n\n\n\n\nBefehl\nErgebniss\nLaufzeit (real)\n\n\ntime ./binomial 10 4\ntime ./binomial_fast 10 4\n210\n210\nreal 0m0,004s\nreal 0m0,004s\n\n\ntime ./binomial 11 6\ntime ./binomial_fast 11 6\n462\n462\nreal 0m0,005s real 0m0,005s\n\n\ntime ./binomial 13 10\ntime ./binomial_fast 13 10\n286\n88\nreal 0m0,005s\nreal 0m0,004s\n\n\ntime ./binomial 20 13\ntime ./binomial_fast 20 13\n77520\n-2\nreal 0m0,006s\nreal 0m0,002s\n\n\ntime ./binomial 27 15\ntime ./binomial_fast 27 15\n17383860\n0\nreal 0m0,123s\nreal 0m0,004s\n\n\ntime ./binomial 32 15\ntime ./binomial_fast 32 15\n565722720\n-3\nreal 0m3,519s\nreal 0m0,004s\n\n\ntime ./binomial 34 19\ntime ./binomial_fast 34 19\n1855967520\n0\nreal 0m11,689s\nreal 0m0,002\n\n\ntime ./binomial 36 13\ntime ./binomial_fast 36 13\n-1984177696\n0\nreal 0m15,388s\nreal 0m0,004s\n\n\ntime ./binomial 39 23\ntime ./binomial_fast 39 23\n-943444674\ncore dumped\nreal 3m47,934s\nreal 0m0,086s\n\n\n\n\nDa binomial_fast eine lineare Laufzeitkomplezitaet hat bleibt die Laufzeit c. .004s fuer alle Eingaben.\nIm Gegensatz waechst die Laufzeit von binomial proportional zu dem mathematischen Wert \\(B_{n, k}\\) fuer Eingaben \\(n\\) und \\(k\\). Somit ist die Laufzeit sehr hoch fuer grosse Werte von \\(B_{n, k}\\).\nWie aus der Tabelle zu sehen ist, gibt es bereits ab \\(n = 27, k = 15\\) einen Unterschied und fuer hoehere Werte wie \\(n = 34, k = 19\\) oder \\(n = 36, k = 13\\) unterscheiden sich die Laufzeiten um mehr als 10s. Fuer \\(n = 39, k = 23\\) ist die Laufzeit von binomial sogar fast 4 minuten, wobei binomial_fast immer noch bei ~0.004s bleibt.\n\n\n3.5\nFuer diese Teilaufgabe verwenden wir wieder die obige Tabelle Table 1. Fuer die ersten zwei Zeilen, also fuer \\(n = 10, k = 4\\) und \\(n = 11, k = 6\\) liefern beide Programme die richtige mathematische Ergebnisse \\(\\binom{10}{4} = 210\\), bzw. \\(\\binom{11}{6} = 462\\). Jedoch liefert binomial_fast bereits ab der dritten Zeile, also fuer \\(n = 13, k = 10\\) ein falsches Ergebnis, wobei binomial bis der 7en Zeile, d.h fuer \\(n = 34, k = 19\\) richtige Ergebnisse liefert.\nWie in der Teilaufgabe 3.3 erklaert wurde, gibt es das sogenannte Phaenomen “overflow” fuer den Datentyp int. Die Fakultaetsfunktion waechst sehr schnell und hat bereits fuer die Eingabe 13 den Wert \\(13! = 6 227 020 800 &gt; 2 147 483 647 = 2^{31} - 1\\). Somit fuehrt bereits fak(13) zu einem overflow. Da, die Implementierung vonbinomial_fast die Funktion fak benutzt, liefert dieses Program fuer Eingaben \\(n \\geq 13\\) ein falsches Ergebnis."
  },
  {
    "objectID": "04/04.html#aufgabe-1",
    "href": "04/04.html#aufgabe-1",
    "title": "Zettel 04",
    "section": "Aufgabe 1",
    "text": "Aufgabe 1\nLaut link existieren folgende verschiedene “Data Models”, die die Groesse der Grunddatengypen festlegen:\n\n1.1\n\nLP32(32 bit Systeme):\n\nint: 16-bit\nlong: 32-bit\npointer: 32-bit\n\nILP32(32 bit Systeme):\n\nint: 32-bit\nlong: 32-bit\npointer: 32-bit\n\nLLP64(32 bit Systeme):\n\nint: 32-bit\nlong: 32-bit\npointer: 64-bit\n\nLP64(32 bit Systeme):\n\nint: 32-bit\nlong: 64-bit\npointer: 64-bit\n\n\nSomit ist long mindestens 32-bit kann aber auch 64-bit sein.\n\n\n1.2\nBezeichne \\([\\texttt{S}|\\texttt{E}|\\texttt{M}]_{\\texttt{FP32}}\\) Die IEEE754 Fliesskommadarstellung einer zahl, wobei \\(S := \\text{sign bit}\\), \\(E := \\text{Exponent}\\), \\(M := \\text{Mantisse}\\), und sei \\([\\texttt{S|E|M}]_2\\) die 2-Bit Ganzzahldarstellung der selben Bitfolge.\nDann gilt:\n\\[\\begin{align*}\n    \\log_2(y) &= \\log([\\texttt{0|E|M}]_{\\texttt{FP32}}) \\tag{fuer ein $y &gt;= 0$ im gueltigen Bereich} \\\\\n              &= \\log_2((1 + \\frac{M}{2^{23}})2^{\\texttt{E} - 127}) \\tag{Interpretation von $[\\bullet]_{\\texttt{FP32}}$} \\\\\n              &= \\log_2(1 + \\frac{M}{2^{23}}) + \\texttt{E} - 127 \\tag{Rechenregeln fuer $\\log$} \\\\\n              &\\approx \\frac{\\texttt{M}}{2^{23}} + \\mu + \\texttt{E} - 127 \\tag{$\\log_2(1 + x) \\approx x + \\mu$} \\\\\n              &= \\frac{1}{2^{23}}(\\mu + 2^{23} + E) + \\mu - 127 \\tag{arithmetik} \\\\\n              &= \\frac{1}{2^{23}}[\\texttt{0|E|M}]_2 + \\mu - 127 \\tag{Interpretation von $[\\bullet]_2$} \\\\\n              &= \\alpha\\cdot [\\texttt{0|E|M}]_2 + \\beta \\tag{$\\alpha, \\beta$ bestimmte Konstanten}\n\\end{align*}\\]\nDiese Umformungen stellen die Bezieuhung zwischen dem Logarithmus einer zahl \\(y\\) und der Bitfolge ihrer IEEE754 FP Darstellung dar: Interpreteriert man die Bitfolge als eine 2-Bit Ganzahl, so besteht ein linearer Zusammenhang zwischem dem Logarithmus und die zur 2-Bit Bitfolge entsprechende Ganzzahl, sie unterscheiden sich approximativ lediglich um eine Skalierung und Verschiebung.\n\n\n1.3\ny ist ein float. Mit i = * (long *) &y weisen wir die im y enthaltene Bitfolge zu der Variable i zu und stellen den Typ von i als long fest. Somit enthaelt i die genaue Bitfolge von y aber wird als long interpretiert statt als float. Der numerische Wert von i ist ganz anderes als dies von y aber mit der selben Bitfolge.\nHingegen fuehrt i = (long) y eine automatische Typkonvertierung durch und weist den Wert von y gerundet auf einer Ganzzahl zu i zu. Somit tragen i und y aehnliche numerische Werte aber i hat eine ganz andere Bitfolge von y. Da, wir uns fuer die genaue Bitfolge interessieren und nicht fuer den numerischen wert wuerde das gar nicht funktioneren."
  },
  {
    "objectID": "04/04.html#aufgabe-2",
    "href": "04/04.html#aufgabe-2",
    "title": "Zettel 04",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\nWir verwenden folgenden Definitionen in dem Beweis:\n\n2er Komplementdarstellung:\n\n\\[d_n: [-2^{n-1}, 2^{n-1} - 1] \\rightarrow [0, 2^{n - 1}]\\]\n\nBeschneidung:\n\nBeweis:\n\n\\(\\underline{a = 0}\\)\n\n\\[\\begin{align*}\n    d_n(0) &= d_n(-0) \\tag{$-0 = 0$} \\\\\n           &= s_n(2^n) \\tag{Besch 2} \\\\\n           &= s_n(2^n - 0) \\tag{Arithmetik} \\\\\n           &= s_n(2^n - d_n(0)) \\tag{Dar 1}\n\\end{align*}\\]\n\n\\(\\underline{0 &lt; a &lt; 2^{n - 1}: }\\)\n\n\\[\\begin{align*}\n    d_n(-a) &= 2^n - |a| \\tag{$-a &lt; 0$, Dar 2} \\\\\n            &= 2^n - a \\tag{$a &gt; 0 \\Rightarrow |a| = a$} \\\\\n            &= s_n(2^n - a) \\tag{$2^n - a &lt; 2^n$, Besch 1}  \\\\\n            &= s_n(2^n - d_n(a)) \\tag{$a &gt; 0$, Dar 1}\n\\end{align*}\\]\n\n\\(\\underline{-2^{n-1} &lt; a &lt; 0: }\\)\n\n\\[\\begin{align*}\n    d_n(-a) &= -a \\tag{$-a &gt; 0$, Dar 1} \\\\\n            &= s_n(-a) \\tag{$-a &lt; 2^n$, Besch 1} \\\\\n            &= s_n(2^n - (2^n + a)) \\tag{Arithmetik} \\\\\n            &= s_n(2^n - (2^n - (-a))) \\tag{Arithmetik} \\\\\n            &= s_n(2^n - (2^n - |a|)) \\tag{$a &lt; 0 \\Rightarrow |a| = - a$} \\\\\n            &= s_n(2^n - d_n(a)) \\tag{$a &lt; 0$, Dar 2}\n\\end{align*}\\]"
  },
  {
    "objectID": "04/04.html#aufgabe-3",
    "href": "04/04.html#aufgabe-3",
    "title": "Zettel 04",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\n\n\n\n\\[\\begin{align*}\n    log_2(2n) &= \\log_2(2) + \\log_2(n) \\\\\n              &= 1 + \\log_2(n) \\\\\n              &=\n            \\begin{cases}\n                1 + 4s = 5s, & \\log_2(n) = 4s \\\\\n                1 + 10s = 11s, & \\log_2(n) = 10s \\\\\n                1 + 100s = 101s, & \\log_2(n) = 100s\n            \\end{cases}\n\\end{align*}\\]\n\n\\[\n2n =\n\\begin{cases}\n    2\\cdot 4s = 8s,     & n = 4s \\\\\n    2\\cdot 10s = 20s,   & n = 10s \\\\\n    2\\cdot 100s = 200s, & n = 100s\n\\end{cases}\n\\]\n\\[\n2n\\log_2(2n) =\n\\begin{cases}\n    2\\cdot 4s(1 + 4) = 40s,         & n = 4s \\\\\n    2\\cdot 10s(1 + 10) = 220s,      & n = 10s \\\\\n    2\\cdot 100s(1 + 100) = 20200s,  & n = 100s\n\\end{cases}\n\\]\n\\[\n(2n)^3 = 8n^3\n\\begin{cases}\n    8\\cdot 4s = 40s,        & n = 4s \\\\\n    8\\cot 10s = 80s,        & n = 10s \\\\\n    8\\cdot 100s = 800s,     & n = 100s\n\\end{cases}\n\\]\n\\[\n2^(2n) = (2^n)^2 =\n\\begin{cases}\n     4^2s = 16s,                 & n = 4s \\\\\n     10^2s = 100s,               & n = 10s \\\\\n     100^2s \\approx 2.8 std,     & n = 100s\n\\end{cases}\n\\]\n\n\n\n3.2\nWir fuehren die Notation \\(f \\preceq g :\\iff f \\in \\mathcal{O}(g)\\) ein. Dann gilt:\n\\[\\begin{align*}\n    1 &\\preceq \\log(\\log(n)) \\\\\n      &\\preceq \\log(n) \\\\\n      &\\preceq n^\\epsilon \\\\\n      &\\preceq n^{\\log(n)} \\\\\n      &\\preceq c^{n} \\\\\n      &\\preceq n^{n} \\\\\n      &\\preceq c^{c^n} \\\\\n\\end{align*}\\]"
  },
  {
    "objectID": "04/04.html#aufgabe-4",
    "href": "04/04.html#aufgabe-4",
    "title": "Zettel 04",
    "section": "Aufgabe 4",
    "text": "Aufgabe 4\n\n4.1\nDie Funktion int kantenindex(int i, int j) (Quellcode auch im zip im niklaus.cc enthalten, beachte die fuer die Vereinfachung des Syntax definierten ‘Helferfunktionen’ int abs(int x), int min(int i, int j) und int max(int i, int j)):\nint abs(int x){return cond(x &lt; 0, -x, x);}\n\n//returns minimum of i and j\nint min(int i, int j){return cond(i &gt; j, j, i);}\n\n// returns maximum of i and j\nint max(int i, int j){return cond(i &gt; j, i, j);}\n\nint kantenindex(int i, int j)\n{\n    return cond(\n        i == j || abs(i - j) == 4 || (min(i, j) == 0 && max(i, j) == 3), //Diese Kanten existieren nicht\n        -1, //error code is -1\n        cond(\n            min(i, j) == 2 && max(i, j) == 3, \n            0, \n            i + j));\n}\n\n\n4.2\n\n\n\n//0000 0100 & zzzz zzzz == 0000 0z00 \n//somit i'te kante besucht &lt;=&gt; (2^i & z) != 0\n//wobei 2^i == 1 &lt;&lt; i\nbool kante_besucht(int kante, unsigned char zustand)\n{\n    return ((1 &lt;&lt; kante) & zustand) != 0;\n}\n\n\n\n//0000 0100 | zzzz z0zz == zzz z1zz\n//somit besuche i'te kante: z := z | 2^i\n//wobei 2^i == 1 &lt;&lt; i\nunsigned char besuche_kante(int kante, unsigned char zustand)\n{\n    return zustand | (1 &lt;&lt; kante);\n}"
  },
  {
    "objectID": "05/05.html#aufgabe-1",
    "href": "05/05.html#aufgabe-1",
    "title": "Zettel 05",
    "section": "Aufgabe 1",
    "text": "Aufgabe 1\nSiehe Figure 1\n\n\n  \nFigure 1: Umgebungen bevor \\(\\fbox{1}\\), \\(\\fbox{2}\\), \\(\\fbox{3}\\) ausgefuehrt werden."
  },
  {
    "objectID": "05/05.html#aufgabe-2",
    "href": "05/05.html#aufgabe-2",
    "title": "Zettel 05",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\n\n2.1\nfolgendes Code realisiert die float version der Determinante-funktion:\n#include \"fcpp.hh\"\n\nfloat determinante(\n    float a,\n    float b,\n    float c,\n    float d\n)\n{\n    return a * d - b * c;\n}\n\nint main()\n{\n    return print(determinante(\n        100, 0.01,\n        -0.01, 100\n    ));\n}\nErgebniss: 10000\nErklaerung: Das exakte Ergebniss der Berechnung \\(10000.0001 = 1.00000001\\times 10^4\\) kann nicht mit 32 bit float dargestellt werden. Eine 32-bit float ist eine Bitfolge der Form S|E|M, wobei S der “sign-bit”, 8 E’s die ‘Exponenten-bits’ und 23 M’s die ‘Mantisse-bits’ sind. Diese bitfolge wird interpretiert als:\n\\[\n[S|E|M]_{FP32} := (-1)^S\\times 1.M \\times 2^{E - 127}\n\\]\nDie exakte Darstellung von 1000.0001 in 2er Basis lautet jedoch \\(1.00111000\\ldots11010001101101110001 \\times 2^{13}\\). Hier gibt mehr als 23 Stellen nach der Komma, die der Mantisse entsprechen. Jedoch erlaubt float 23 Stellen fuer die Mantisse. Deshalb kann diese Bitfolge nicht genau representiert werden und wird stattdessen moeglichst praezis gerundet.\nDie Rundung erfuellt die Eigenschaft\n\\[\nrd(x) = x(1 + r), r &lt; eps\n\\]\nWobei \\(r\\) der relative Rundungsfehler, \\(eps\\) die Maschinen-genauigkeit ist. Fuer float lautet dies \\(2^{-23} \\approx 10^{-7}\\).\nDie Rundung \\(rd(1000.0001) = 1000\\) erfuellt tatsaechlich diese Eigenschaft, da \\(r = \\frac{.0001}{10000} = 10^{-8}\\)\nDie double Version des Programms\n#include \"fcpp.hh\"\n\ndouble determinante(\n    double a,\n    double b,\n    double c,\n    double d\n)\n{\n    return a * d - b * c;\n}\n\nint main()\n{\n    return print(determinante(\n        100, 0.01,\n        -0.01, 100\n    ));\n}\nLiefert das mathematisch exakte Ergebniss \\(10000.0001\\). Da, der Datentyp double die 64-bit Fliesskommazahlen realisiert, hat es die Maschinengenauigkeit \\(eps = 2^{-52}\\). Somit koennen mehr siginifikanten Stellen representiert werden als mit 32-bit FP Zahlen. Die Zahl \\(10000.0001\\) hat immer noch keine exakte Darstellung aber da, \\(eps\\) viel kleiner ist liefert die Rundung die exakte Darstellung."
  },
  {
    "objectID": "05/05.html#aufgabe-3",
    "href": "05/05.html#aufgabe-3",
    "title": "Zettel 05",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\n\n3.1\nAequivalente while-Version lautet:\nint fib(int n)\n{\n    int a = 0;\n    int b = 1;\n    int i = 0;\n    //invariante: a == fib(i) && b == fib(i + 1) && i &lt;= n\n    while (i &lt; n){\n        int t = a + b;\n        a = b;\n        b = t\n        i = i + 1;\n    }//i == n =&gt; a == fib(n)\n    return a;\n}\n\nSchleifenvektor: \\(v = (a, b, t, i)\\)\nSchleifenbedingung: \\(B(v) :\\equiv i &lt; n\\)\nSchleifentransformator: \\(H(a, b, t, i) = (b, a + b, a + b, i + 1)\\)\n\n\n\n3.2\n\nVorbedingung: \\(P(n) :\\equiv 0 \\leq n\\)\nBehauptung: \\(Inv(v) :\\equiv (a = fib(i)) \\wedge (b = fib(i + 1)) \\wedge (i\\leq n)\\)\nNachbedingung: \\(Q(v, n) :\\equiv a = fib(n)\\)\n\nBeweis:\nBezeichne \\(v_j := H^j(v)\\)\n\n(IB): Vor der ersten Iteration gilt: \\(v_0 = (a_0, b_0, t_0, i_0) = (0, 1, ?, 0)\\) und somit:\n\n\\[\\begin{align*}\na_0 &= 0 \\\\\n   &= fib(0) \\tag{Def von fib} \\\\\n   &= fib(i_0) \\\\\n\\\\\nb_0 &= 1 \\\\\n   &= fib(1) \\tag{Def von fib} \\\\\n   &= fib(i_0 + 1) \\\\\n\\\\\ni_0 &= 0 \\leq n \\tag{Vorbedingung $P(n)$}\n\\end{align*}\\]\nSomit gilt \\(Inv(v_0)\\)\n\n(IS): Gelte die Invariante vor einer \\(k\\)-ten Iteration, d.h \\[Inv(v_k) :\\equiv (a_k = fib(i_k)) \\wedge (b_k = fib(i_k + 1)) \\wedge (i_k \\leq n)\\] z.z.: \\(Inv(v_k) \\wedge B(v_k) \\Rightarrow Inv(v_{k + 1})\\)\nBew: Es gilt: \\[\\begin{align*}\nInv(v_k) \\wedge B(v_k)\n     \\Leftrightarrow& a_k = fib(i_k) \\wedge b_k = fib(i_k + 1)\n                      \\wedge i_k \\leq n\n                      \\wedge i_k &lt; n \\tag{Def von $Inv(v)$ und $B(v)$} \\\\\n     \\Rightarrow& a_k = fib(i_k) \\wedge b_k = fib(i_k + 1)\n                           \\wedge i_k &lt; n \\tag{Arithmetik} \\\\\n     \\Rightarrow& a_k + b_k = fib(i_k) + fib(i_k + 1) \\wedge b_k = fib(i_k + 1) \\wedge i_k + 1 \\leq n \\tag{Arithmetik} \\\\\n     \\Leftrightarrow& a_k + b_k = fib(i_k + 2) \\wedge b_k = fib(i_k + 1) \\wedge i_k + 1 \\leq n \\tag{Def von $fib$} \\\\\n     \\Leftrightarrow& a_k + b_k = fib((i_k + 1) + 1) \\wedge b_k = fib(i_k + 1) \\wedge i_k + 1 \\leq n \\tag{Arithmetik} \\\\\n     \\Leftrightarrow& b_{k + 1} = fib(i_{k + 1} + 1) \\wedge a_{k + 1} = fib(i_{k + 1}) \\wedge i_{k + 1} \\leq n \\tag{Def von $H$ und $v_{k + 1} = H(v_k)$} \\\\\n     \\Leftrightarrow& Inv(v_{k + 1}) \\quad \\blacksquare \\tag{Def von $Inv(v)$}\n\\end{align*}\\]\nNach dem Verlassen der Schleifen bei einem allgemeinen Schleifenvektor \\(v\\) gilt somit: \\[\\begin{align*}\nInv(v) \\wedge \\neg B(v) &\\Leftrightarrow (a = fib(i) \\wedge b = fib(i + 1) \\wedge i \\leq n) \\wedge \\neg(i &lt; n) \\tag{Def von $Inv$ und $B$} \\\\\n                         &\\Leftrightarrow (a = fib(i) \\wedge b = fib(i + 1)) \\wedge (i \\leq n \\wedge i \\geq n) \\tag{DeMorgan} \\\\\n                         &\\Leftrightarrow (a = fib(i) \\wedge b = fib(i + 1)) \\wedge i = n \\tag{Arithmetik} \\\\\n                         &\\Rightarrow a = fib(n) \\tag{Aussagenlogik} \\\\\n                         &\\Leftrightarrow Q(v, n) \\quad \\blacksquare \\tag{Def der Nachbedingung $Q$}\n\\end{align*}\\]"
  },
  {
    "objectID": "05/05.html#aufgabe-4",
    "href": "05/05.html#aufgabe-4",
    "title": "Zettel 05",
    "section": "Aufgabe 4",
    "text": "Aufgabe 4\nWir betrachten 4 Faelle:\nFall \\(a, b \\geq 0\\):\n\\[\\begin{align*}\n    s_n(d_n(a) \\cdot d_n(b)) &= s_n(a \\cdot b) \\tag{Def $d_n$} \\\\\n                             &= a \\cdot b \\tag{$ab \\leq 2^{n - 1} &lt; 2^n$, Def $s_n$} \\\\\n                             &= d_n(ab) \\tag{$ab \\geq 0$}\n\\end{align*}\\]\nFall \\(a, b &lt; 0\\):\n\\[\\begin{align*}\n    s_n(d_n(a)\\cdot d_n(b)) &= s_n((2^n - |a|)(2^n - |b|)) \\tag{Def $d_n$} \\\\\n                            &= s_n((2^n +a)(2^n + b)) \\tag{$a, b &lt; 0$} \\\\\n                            &= s_n(4^n + 2^n(a + b) ab) \\\\\n                            &= s_n(2^n(2^n + a + b) + ab) \\\\\n                            &= a\\cdot b \\tag{$0\\leq 2^n + a + b &lt; 2^n$, Def $s_n$} \\\\\n                            &= d_n(ab) \\tag{$ab &gt; 0$, Def $d_n$}\n\\end{align*}\\]\nFall o.B.d.A \\(a &lt; 0, b &gt; 0\\):\n\\[\\begin{align*}\n    s_n(d_n(a)d_n(b)) &= s_n((2^n - |a|)b) \\tag{$a &lt; 0$, Def $d_n$} \\\\\n                      &= s_n((2^n + a)b) \\tag{$a &lt; 0$} \\\\\n                      &= s_n(2^nb + ab) \\\\\n                      &= s_n(2^nb - |ab|) \\tag{$ab &lt; 0$} \\\\\n                      &= s_n(2^nb - 2^n + (2^n - |ab|)) \\\\\n                      &= s_n(2^n(b - 1) + (2^n - |ab|)) \\\\\n                      &= 2^n - |ab| \\tag{$b\\geq 1$, Def $s_n$} \\\\\n                      &= d_n(ab) \\tag{Def $d_n$}\n\\end{align*}\\]\nFall o.B.d.A \\(b = 0\\):\n\\[\\begin{align*}\n    s_n(d_n(a)d_n(0)) &= s_n(d_n(a)\\cdot 0) \\\\\n                      &= s_n(0) \\\\\n                      &= 0 \\\\\n                      &= d_n(0) \\\\\n                      &= d_n(a\\cdot 0)  \n\\end{align*}\\]"
  },
  {
    "objectID": "06/06.html#aufgabe-1",
    "href": "06/06.html#aufgabe-1",
    "title": "Zettel 06",
    "section": "Aufgabe 1",
    "text": "Aufgabe 1\ncircular_buffer.cc (auch im Zip enthalten)\nUm die Lesbarkeit der Ausgabe zu vereinfachen interpretieren wir 0 als leeres Slot. Somit wenn ein slot gelesen wird, wird sein Wert durch 0 ersetzt, d.h. ‘geloescht’.\n#include &lt;stdio.h&gt;\n#define N 10\n\nint buffer [N];\n\nint w = 0; //write index\nint r = 0; //read index \n\nint use_size = 0; //count of the elements in buffer\n\nint read()\n{\n    if (use_size == 0) //buffer empty, return error code -1\n        return -1;\n    int i = r; //i holds current read index \n    r = (r + 1) % N; //increment read index modulo N\n    use_size--; //one less element in the buffer, decrement size\n    int output = buffer[i];\n    buffer[i] = 0; //0 value corresponds to an empty slots, i.e. deletion of an element\n    return output;\n}\n\nvoid write (int item)\n{\n    if (use_size == N){ //buffer full, overwrite with warning. \n        printf(\"Warning: buffer full, overwriting oldest element!\\n\");\n        buffer[w] = item;\n        w = (w + 1) % N; //increment write index modulo N\n        r = w; //when buffer full w == r is true\n    } \n    else {\n        buffer[w] = item;\n        w = (w + 1) % N;\n        use_size++;\n    } \n}\n\nvoid print_buffer()\n{\n    printf(\"buffer = [\\n\");\n    for (int i = 0; i &lt; N; i++){\n        if (w != i && r != i) printf(\"  %d\\n\", buffer[i]);\n        if (w != i && r == i) printf(\"&lt; %d\\n\", buffer[i]);\n        if (w == i && r != i) printf(\"&gt; %d\\n\", buffer[i]);\n        if (w == i && r == i) printf(\"&gt;&lt;%d\\n\", buffer[i]);\n    }\n    printf(\"]\\n\\n\");\n};\n\nint main()\n{\n    //initialize buffer\n    for (int i = 0; i &lt; N; i++) buffer[i] = 0; //since buffer contains only positive\n                                               // set everything initially to 0 representing empty slots\n    int i = 13497 % N; //or any other initial random index\n    buffer[i] = 1; //set the slot in this index to 1, everything else is 0\n    r = i; //initial read index \n    w = (i + 1) % N; //initial write index \n    use_size = 1; //initially one element in buffer\n\n    int input; //menu option\n    do {\n        printf(\"input: \");\n        scanf(\"%d\", &input);\n        if (input == -1) break;\n        else if (input == 0){\n            int item = read();\n            if (item == -1) printf(\"buffer is empty\\n\");\n            else {\n                printf(\"\\nout: %d\\n\", item);\n                print_buffer();\n            }\n        } else if (input &gt; 0){\n                write(input);\n                print_buffer();\n        } else printf(\"invalid option!\\n\");\n \n    } while (input != -1);\n    return 0;\n}"
  },
  {
    "objectID": "06/06.html#aufgabe-2",
    "href": "06/06.html#aufgabe-2",
    "title": "Zettel 06",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\n\n8 mal fuer out-shuffle\n52 mal fuer in-shuffle\n\nshuffle.cc (siehe zip).\n#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#define N 52\n\nint deck[N];\n\n//we need this division operation to cover cases when n is odd\n//because for odd n we want to get ceiling(n/2) and use it when copying arrays in the shuffle functions\n//otherwise the indices don't quite work for odd cases the way we implement shuffle functions\nint div2(int n)\n{\n    if (n & 1) return n/2 + 1;\n    return n/2;\n}\n\nbool deck_check(int deck[], int n)\n{\n    for (int i = 0; i &lt; n; i++){\n        if(i != deck[i]) return false;\n    }\n    return true;\n}\n\nvoid out_shuffle(int deck[], int n)\n{\n    int temp[n];\n    //write shuffled values to temp\n    for (int i = 0; i &lt; div2(n); i++) temp[2*i] = deck[i]; //even indices get upper half of deck\n    for (int i = 0; i &lt; div2(n); i++) temp[2*i + 1] = deck[div2(n) + i]; //odd indices get lower half of deck\n    //write temp to deck\n    for (int i = 0; i &lt; n; i++) deck[i] = temp[i];\n}\n\nvoid in_shuffle(int deck[], int n)\n{\n    int temp[n];\n    for (int i = 0; i &lt; n/2; i++) temp[2*i + 1] = deck[i]; //odd indices get upper half of the deck\n    for (int i = 0; i &lt; div2(n); i++) temp[2*i] = deck[n/2 + i]; //odd indices get upper half of the deck\n    for (int i = 0; i &lt; n; i++) deck[i] = temp[i];\n}\n\nint main()\n{\n    //initialize deck for out-shuffling\n    for (int i = 0; i &lt; N; i++) deck[i] = i;\n\n    out_shuffle(deck, N); //deck out-shuffled once\n    int count = 1; //how many times have the deck been shuffled? \n    while (!deck_check(deck, N)){\n        out_shuffle(deck, N);\n        count++;\n    }\n    printf(\"how many times to repeat out-shuffle to get initial configuration? %d\\n\", count);\n\n\n    //initialize deck for in-shuffling\n    for (int i = 0; i &lt; N; i++) deck[i] = i;\n\n    in_shuffle(deck, N); //deck in-shuffled once\n    count = 1; //how many times have the deck been shuffled? \n    while (!deck_check(deck, N)){\n        in_shuffle(deck, N);\n        count++;\n    }\n    printf(\"how many times to repeat in-shuffle to get initial configuration? %d\\n\", count);\n\n    // some simple tests below, not relevant to the problem\n    // for (int i = 0; i &lt; N; i++) deck[i] = i;\n    // for (int i = 0; i &lt; N; i++) printf(\"%d %d\\n\", i, deck[i]);\n    // printf(\"\\n\\n\");\n    // in_shuffle(deck, N);\n    // for (int i = 0; i &lt; N; i++) printf(\"%d %d\\n\", i, deck[i]);\n    // printf(\"\\n\\n\");\n\n    return 0;\n}"
  },
  {
    "objectID": "06/06.html#aufgabe-3",
    "href": "06/06.html#aufgabe-3",
    "title": "Zettel 06",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3"
  }
]